var documenterSearchIndex = {"docs":
[{"location":"core/#ExaModelsPower.mpopf_model-Tuple{Any, Any}","page":"API Manual","title":"ExaModelsPower.mpopf_model","text":"mpopf_model(filename, curve; kwargs...)\nmpopf_model(filename, active_power_data, reactive_power_data; kwargs...)\nmpopf_model(filename, curve, discharge_func::Function; kwargs...)\nmpopf_model(filename, active_power_data, reactive_power_data, discharge_func::Function; kwargs...)\n\nConstruct a multi-period AC optimal power flow (MPOPF) model using different formats of load input data.\n\nArguments\n\nfilename::String: Path to the network data file (e.g., MATPOWER).\ncurve::AbstractVector: A time series of demand multiplier values.\nactive_power_data::String: Path to a matrix of active power loads (Pd) per bus and time.\nreactive_power_data::String: Path to a matrix of reactive power loads (Qd).\ndischarge_func::Function: (Optional) A function specifying battery discharge losses.\n\nKeyword Arguments\n\nN::Int: Number of time periods (inferred if not provided).\ncorrective_action_ratio::Float64: Ratio of corrective power action allowed (default = 0.1).\nbackend: Optimization solver backend (deault = nothing).\nform::Symbol: Power flow formulation, either :polar or :rect (default = :polar).\nT::Type: Floating-point type for numeric variables (default = Float64).\nstorage_complementarity_constraint::Bool: Whether to enforce complementarity for storage (only for some methods, default = false).\nkwargs...: Additional arguments passed to the solver or builder.\n\nReturns\n\nA vector (model::ExaModel object, variables::NamedTuple of variables, constraints::NamedTuple of constraints) representing the MPOPF model.\n\nMethod Variants\n\nThis function is overloaded for different combinations of input:\n\nmpopf_model(filename, curve)\nmpopf_model(filename, active_power_data, reactive_power_data)\nmpopf_model(filename, curve, discharge_func)\nmpopf_model(filename, active_power_data, reactive_power_data, discharge_func)\n\n\n\n\n\n","category":"method"},{"location":"core/#ExaModelsPower.opf_model-Tuple{Any}","page":"API Manual","title":"ExaModelsPower.opf_model","text":"opf_model(filename; backend, T, form)\n\nReturn ExaModel, variables, and constraints for a static AC Optimal Power Flow (ACOPF) problem from the given file.\n\nArguments\n\nfilename::String: Path to the data file.\nbackend: The solver backend to use. Default if nothing.\nT: The numeric type to use (default is Float64).\nform: Voltage representation, either :polar or :rect. Default is :polar.\nkwargs...: Additional keyword arguments passed to the model builder.\n\nReturns\n\nA vector (model, variables, constraints):\n\nmodel: An ExaModel object.\nvariables: NamedTuple of model variables.\nconstraints: NamedTuple of model constraints.\n\n\n\n\n\n","category":"method"},{"location":"mpopf_demo/#mpopf_demo","page":"Multi-period OPF","title":"Multi-period OPF","text":"","category":"section"},{"location":"mpopf_demo/","page":"Multi-period OPF","title":"Multi-period OPF","text":"The multi-period (MP) OPF can also be modeled in ExaModelsPower with a number of user-specified adjustments, including storage.","category":"page"},{"location":"mpopf_demo/","page":"Multi-period OPF","title":"Multi-period OPF","text":"Some of the models in this portion of the tutorial involve using external files. While we provide the necessary code to access these additional files, you may view them here as well. We will start with the simplest way to model the MPOPF, which also does not require the user to have any data already downloaded. Instead, the user specifies a demand curve for the system. The demand curve is a vector of ratios from 0 to 1 which indicate the scaling of demand compared to the demand indicated by the static OPF file. In this model of the MPOPF, every consuming bus has the same scaling in power demand for each point in time. A corrective action ratio, which limits the ramp rate of generators, can also be inputted. It is set to 0.1 as a default. The adjustable coordinate system and backend that were present for the static OPF are also available for all MPOPF models.","category":"page"},{"location":"mpopf_demo/","page":"Multi-period OPF","title":"Multi-period OPF","text":"using ExaModelsPower, CUDA, MadNLP, MadNLPGPU, ExaModels\nmodel, vars, cons = mpopf_model(\n    \"pglib_opf_case118_ieee.m\", # static network data\n    [.64, .60, .58, .56, .56, .58, .64, .76, .87, .95, .99, 1.0, .99, 1.0, 1.0,\n    .97, .96, .96, .93, .92, .92, .93, .87, .72, .64], #Demand curve\n    backend = CUDABackend(),\n    corrective_action_ratio = 0.3\n)\nresult = madnlp(model; tol=1e-6)","category":"page"},{"location":"mpopf_demo/","page":"Multi-period OPF","title":"Multi-period OPF","text":"\"Execution stats: Optimal Solution Found (tol = 1.0e-06).\"","category":"page"},{"location":"mpopf_demo/","page":"Multi-period OPF","title":"Multi-period OPF","text":"If the user would like to provide more complex demand profiles, they can provide their own input files. The number of rows in each input file should match the number of buses in the static OPF datafile, and the number of columns will dictate the number of time periods in the MP model. First, download the example load profile datafiles.","category":"page"},{"location":"mpopf_demo/","page":"Multi-period OPF","title":"Multi-period OPF","text":"using Downloads\n\n#Define URLs for Pd and Qd data files (raw or raw GitHub links)\npd_url = \"https://raw.githubusercontent.com/mit-shin-group/multi-period-opf-data/refs/heads/main/halfhour_30.Pd\"\nqd_url = \"https://raw.githubusercontent.com/mit-shin-group/multi-period-opf-data/refs/heads/main/halfhour_30.Qd\"\n\n#Define local paths to temporarily store the files\npd_file = \"halfhour_30.Pd\"\nqd_file = \"halfhour_30.Qd\"\n\n#Download the files if they don't already exist\nif !isfile(pd_file)\n    Downloads.download(pd_url, pd_file)\nend\n\nif !isfile(qd_file)\n    Downloads.download(qd_url, qd_file);\nend","category":"page"},{"location":"mpopf_demo/","page":"Multi-period OPF","title":"Multi-period OPF","text":"\"halfhour_30.Qd\"","category":"page"},{"location":"mpopf_demo/","page":"Multi-period OPF","title":"Multi-period OPF","text":"Next, build the MPOPF model, providing the dynamic load data instead of a demand curve as input.","category":"page"},{"location":"mpopf_demo/","page":"Multi-period OPF","title":"Multi-period OPF","text":"#Run your model\nmodel, vars, cons = mpopf_model(\n    \"pglib_opf_case30_ieee.m\",  # static network data (assumed local or already handled)\n    pd_file,                    # dynamic load data (Pd)\n    qd_file;                    # dynamic load data (Qd)\n    backend = CUDABackend()\n)\n\n#Solve\nresult = madnlp(model; tol=1e-6)\n\n# MPOPF with storage","category":"page"},{"location":"mpopf_demo/","page":"Multi-period OPF","title":"Multi-period OPF","text":"\"Execution stats: Optimal Solution Found (tol = 1.0e-06).\"","category":"page"},{"location":"mpopf_demo/","page":"Multi-period OPF","title":"Multi-period OPF","text":"The MPOPF model can also be constructed with storage considerations. We model storage using the model proposed in Geth, Coffrin, Fobes 2020. This requires inputting a modified datafile containing storage parameters. When modeling MPOPF with storage, all of the aforementioned tuneable parameters are still available. We also allow the user to specify whether or not to model the charging/discharging complementarity constraint. This is set to false by default to avoid potential numerical error.","category":"page"},{"location":"mpopf_demo/","page":"Multi-period OPF","title":"Multi-period OPF","text":"#First, we download the modified datafile with storage parameters included.\n#Define URL for the main datafile\nstor_url = \"https://raw.githubusercontent.com/mit-shin-group/multi-period-opf-data/refs/heads/main/pglib_opf_case30_ieee_mod.m\"\n\n#Define local path to temporarily store the file\nstor_file = \"pglib_opf_case30_ieee_mod.m\"\n\n#Download the file if it doesn't already exist\nif !isfile(stor_file)\n    Downloads.download(stor_url, stor_file);\nend","category":"page"},{"location":"mpopf_demo/","page":"Multi-period OPF","title":"Multi-period OPF","text":"\"pglib_opf_case30_ieee_mod.m\"","category":"page"},{"location":"mpopf_demo/","page":"Multi-period OPF","title":"Multi-period OPF","text":"Generate the model with your modified datafile. If the datafile contains storage parameters, ExaModelsPower will automatically recognize it and include the additional necessary constraints.","category":"page"},{"location":"mpopf_demo/","page":"Multi-period OPF","title":"Multi-period OPF","text":"model, vars, cons = mpopf_model(\n    stor_file, # static network data with storage parameters\n    pd_file,                    # dynamic load data (Pd)\n    qd_file;                    # dynamic load data (Qd)\n    backend = CUDABackend(),\n    storage_complementarity_constraint = false\n)\nresult = madnlp(model; tol=1e-6)\nresult.objective","category":"page"},{"location":"mpopf_demo/","page":"Multi-period OPF","title":"Multi-period OPF","text":"299068.0404892951","category":"page"},{"location":"mpopf_demo/","page":"Multi-period OPF","title":"Multi-period OPF","text":"ExaModelsPower also provides a secondary option to avoid dealing with complementarity constraints. The user can specify a function that computesloss in battery level as a smooth function of discharge rate and the storage devices thermal rating parameter. We provide an arbitrary example function to demonstrate the modeling capability.","category":"page"},{"location":"mpopf_demo/","page":"Multi-period OPF","title":"Multi-period OPF","text":"function example_function(d, srating)\n    return d + .2/srating*d^2\nend;","category":"page"},{"location":"mpopf_demo/","page":"Multi-period OPF","title":"Multi-period OPF","text":"ExaModelsPower will automatically adjust the necessary constraints if one of the inputs provided is a function.","category":"page"},{"location":"mpopf_demo/","page":"Multi-period OPF","title":"Multi-period OPF","text":"model, vars, cons = mpopf_model(\n    stor_file, # static network data with storage parameters\n    pd_file,                    # dynamic load data (Pd)\n    qd_file,                    # dynamic load data (Qd)\n    example_function;           # discharge function\n    backend = CUDABackend(),\n    storage_complementarity_constraint = false\n)\nresult = madnlp(model; tol=1e-6)\nresult.objective","category":"page"},{"location":"mpopf_demo/","page":"Multi-period OPF","title":"Multi-period OPF","text":"299044.3240453917","category":"page"},{"location":"mpopf_demo/","page":"Multi-period OPF","title":"Multi-period OPF","text":"Despite the example discharge function being generated somewhat arbitrarily, the resultant objective values remain quite close for both the smooth and piecewise charge/discharge functions.","category":"page"},{"location":"mpopf_demo/","page":"Multi-period OPF","title":"Multi-period OPF","text":"","category":"page"},{"location":"mpopf_demo/","page":"Multi-period OPF","title":"Multi-period OPF","text":"This page was generated using Literate.jl.","category":"page"},{"location":"opfs_doc/#Optimal-Power-Flow-Formulation","page":"OPF Formulations","title":"Optimal Power Flow Formulation","text":"","category":"section"},{"location":"opfs_doc/","page":"OPF Formulations","title":"OPF Formulations","text":"The AC optimal power flow (ACOPF) formulation is a problem characterizing the nonlinear optimization problem which independent service operators must solve to route power through transmission systems. The OPF has also been built upon, leading to even more complex models that account for other considerations such as multiperiodicity and reliability. This documentation provides a brief outline of the key features of each version of the OPF modeled in ExaModelsPower.jl.","category":"page"},{"location":"opfs_doc/#Static-OPF","page":"OPF Formulations","title":"Static OPF","text":"","category":"section"},{"location":"opfs_doc/","page":"OPF Formulations","title":"OPF Formulations","text":"The static OPF is the most basic version of the OPF, implemented over just a single time period. While some simplifications can be made to the model to make it easier to solve, the version implemented in ExaModelsPower.jl is the full, unrelaxed version. The focal constraint in the static OPF is the power balance - this constraint requires that the power generated at each bus is matched by the power consumed, shunt losses, and net power flow from the bus to others via transmission lines. ","category":"page"},{"location":"opfs_doc/","page":"OPF Formulations","title":"OPF Formulations","text":"A central complexity of the ACOPF is calculating the power transfer along transmission lines, which requires the following nonlinear constraint in polar coordinates, where G and B are parameters of the line, n and m are bus indeces, and V and θ represent voltage and phase angle. ","category":"page"},{"location":"opfs_doc/","page":"OPF Formulations","title":"OPF Formulations","text":"P_n = sum_mk V_n V_m left( G_nmk cos theta_nm + B_nmk sin theta_nm right)","category":"page"},{"location":"opfs_doc/","page":"OPF Formulations","title":"OPF Formulations","text":"Due to the computational challenges introduced by these equations, ExaModelsPower.jl implements the OPF in both polar and rectangular coordinates to provide flexibility in the case that a certain algorithm may be more capable of performing computations for certain forms of nonlinear equations. ","category":"page"},{"location":"opfs_doc/","page":"OPF Formulations","title":"OPF Formulations","text":"A more complete description of the static OPF can be found here.","category":"page"},{"location":"opfs_doc/#Multi-period-OPF","page":"OPF Formulations","title":"Multi-period OPF","text":"","category":"section"},{"location":"opfs_doc/","page":"OPF Formulations","title":"OPF Formulations","text":"The multi-period OPF (MPOPF) is a simple variant of the static OPF, but it can introduce powerful results. The MPOPF expands variables across time periods, requiring the same balance as in the static OPF to be balanced for each time period. This allows for the evaluation of real-world problems that involve fluctuating demand over time. The MPOPF also introduces an additional constraint to restrict how quickly generators can ramp up or down. ","category":"page"},{"location":"opfs_doc/","page":"OPF Formulations","title":"OPF Formulations","text":"-Delta P leq P_gt - P_gt-1 leq Delta P","category":"page"},{"location":"opfs_doc/#MPOPF-with-storage","page":"OPF Formulations","title":"MPOPF with storage","text":"","category":"section"},{"location":"opfs_doc/","page":"OPF Formulations","title":"OPF Formulations","text":"The MPOPF also enables the introduction of storage devices to the model. We model storage devices as discussed in Geth, Coffrin, Fobes 2020 [2]. Transfer of power to and from storage devices along with associated losses are now included in the overall power balance for each bus. ","category":"page"},{"location":"opfs_doc/","page":"OPF Formulations","title":"OPF Formulations","text":"One challenge of implementing storage is the complementarity constraint that prevents storage devices from charging and discharging simultaneously. In order to not introduce integer variables, the constraint is implemented as so:","category":"page"},{"location":"opfs_doc/","page":"OPF Formulations","title":"OPF Formulations","text":"P_d cdot P_c = 0","category":"page"},{"location":"opfs_doc/","page":"OPF Formulations","title":"OPF Formulations","text":"This formulation can lead to errors arising from numerical imprecision. As a result, ExaModelsPower.jl provides several options to avoid the explicit implementation of this complementarity constraint. ","category":"page"},{"location":"opf_demo/#opf_demo","page":"Static OPF","title":"Static OPF","text":"","category":"section"},{"location":"opf_demo/","page":"Static OPF","title":"Static OPF","text":"ExaModelsPower.jl can model large-scale optimal power flow (OPF) problems using the ExaModels package to generate models that can be solved using either CPU or GPU. This tutorial will demonstrate how ExaModelsPower.jl can be leveraged to solve different versions of the OPF, and how the user can customize the solving technique to better match their needs. Currently, all models generated by ExaModelsPower represent the full, AC version of the OPF formulation without any simplifications.","category":"page"},{"location":"opf_demo/","page":"Static OPF","title":"Static OPF","text":"The latest version of ExaModelsPower can be installed in julia as so. Additionally, in order to develop models that can be solved on the GPU, CUDA is required.","category":"page"},{"location":"opf_demo/","page":"Static OPF","title":"Static OPF","text":"using ExaModelsPower, CUDA","category":"page"},{"location":"opf_demo/","page":"Static OPF","title":"Static OPF","text":"In order to solve the ExaModels developed by ExaModelsPower, an NLP solver is required. ExaModels is compatible with MadNLP and Ipopt, but this tutorial will focus on MadNLP to demonstrate GPU solving capabilities.","category":"page"},{"location":"opf_demo/","page":"Static OPF","title":"Static OPF","text":"using MadNLP, MadNLPGPU #, NLPModelsIpopt","category":"page"},{"location":"opf_demo/","page":"Static OPF","title":"Static OPF","text":"Finally, we install ExaModels to allow solved models to be unpacked.","category":"page"},{"location":"opf_demo/","page":"Static OPF","title":"Static OPF","text":"using ExaModels","category":"page"},{"location":"opf_demo/","page":"Static OPF","title":"Static OPF","text":"We will begin by constructing and solving a static OPF using the function opf_model. For the static OPF, the only input required is the filename for the OPF matpower file. The file does not need to be locally installed, and it will be automatically downloaded from power-grid-library if the file is not found in the user's data folder. If keywords are not specified, the numerical type will default to Float64, the backend will default to nothing (used on CPU) and the form will default to polar coordinates.","category":"page"},{"location":"opf_demo/","page":"Static OPF","title":"Static OPF","text":"model, vars, cons = opf_model(\n    \"pglib_opf_case118_ieee.m\";\n    backend = CUDABackend(),\n    form = :polar,\n    T = Float64\n);\nmodel","category":"page"},{"location":"opf_demo/","page":"Static OPF","title":"Static OPF","text":"An ExaModel{Float64, CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}, ...}\n\n  Problem name: Generic\n   All variables: ████████████████████ 1088   All constraints: ████████████████████ 1539  \n            free: ███⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 118               free: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     \n           lower: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0                lower: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     \n           upper: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0                upper: █████⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 372   \n         low/upp: ██████████████████⋅⋅ 935            low/upp: ███⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 186   \n           fixed: █⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 35               fixed: █████████████⋅⋅⋅⋅⋅⋅⋅ 981   \n          infeas: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0               infeas: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     \n            nnzh: ( 98.57% sparsity)   8474            linear: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     \n                                                    nonlinear: ████████████████████ 1539  \n                                                         nnzj: ( 99.65% sparsity)   5925  \n\n","category":"page"},{"location":"opf_demo/","page":"Static OPF","title":"Static OPF","text":"Once the model is built, we can generate a solution using MadNLP.","category":"page"},{"location":"opf_demo/","page":"Static OPF","title":"Static OPF","text":"result = madnlp(model; tol=1e-6)","category":"page"},{"location":"opf_demo/","page":"Static OPF","title":"Static OPF","text":"\"Execution stats: Optimal Solution Found (tol = 1.0e-06).\"","category":"page"},{"location":"opf_demo/","page":"Static OPF","title":"Static OPF","text":"Once a solution has been generated, the values of any of the variables in the model can be unpacked using the vars NamedTuple.","category":"page"},{"location":"opf_demo/","page":"Static OPF","title":"Static OPF","text":"solution(result, vars.vm)[1:10]","category":"page"},{"location":"opf_demo/","page":"Static OPF","title":"Static OPF","text":"10-element CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}:\n 1.0580725147178394\n 1.011521414605091\n 1.037194544088092\n 1.0127115639224442\n 1.0170524545911737\n 1.0544369316737237\n 1.0575146839020808\n 1.030351103446915\n 1.0418501518766294\n 1.051935952778422","category":"page"},{"location":"opf_demo/","page":"Static OPF","title":"Static OPF","text":"Result also stores the objective value.","category":"page"},{"location":"opf_demo/","page":"Static OPF","title":"Static OPF","text":"result.objective","category":"page"},{"location":"opf_demo/","page":"Static OPF","title":"Static OPF","text":"97210.50257421113","category":"page"},{"location":"opf_demo/","page":"Static OPF","title":"Static OPF","text":"ExaModelsPower supports solving the OPF in either polar or rectangular coordinates.","category":"page"},{"location":"opf_demo/","page":"Static OPF","title":"Static OPF","text":"model, vars, cons = opf_model(\n    \"pglib_opf_case118_ieee.m\";\n    form = :rect\n)\nresult = madnlp(model; tol=1e-6)\nresult.objective","category":"page"},{"location":"opf_demo/","page":"Static OPF","title":"Static OPF","text":"97213.6075465086","category":"page"},{"location":"opf_demo/","page":"Static OPF","title":"Static OPF","text":"In this case, the objective value and performance speed is comparable. However, for some cases, MadNLP can only solve the problem on one of the two available coordinate systems.","category":"page"},{"location":"opf_demo/","page":"Static OPF","title":"Static OPF","text":"","category":"page"},{"location":"opf_demo/","page":"Static OPF","title":"Static OPF","text":"This page was generated using Literate.jl.","category":"page"},{"location":"Introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"Introduction/","page":"Introduction","title":"Introduction","text":"Welcome to the documentation of ExaModelsPower.jl\t","category":"page"},{"location":"Introduction/","page":"Introduction","title":"Introduction","text":"note: Note\nExaModelsPower runs on julia VERSION ≥ v\"1.9\"","category":"page"},{"location":"Introduction/","page":"Introduction","title":"Introduction","text":"warning: Warning\nPlease help us improve ExaModelsPower and this documentation! ExaModelsPower is in the early stage of development, and you may encounter unintended behaviors or missing documentations. If you find anything is not working as intended or documentation is missing, please open issues or pull requests or start discussions. ","category":"page"},{"location":"Introduction/#What-is-ExaModelsPower.jl?","page":"Introduction","title":"What is ExaModelsPower.jl?","text":"","category":"section"},{"location":"Introduction/","page":"Introduction","title":"Introduction","text":"ExaModelsPower.jl is a Julia package for creating optimal power flow (OPF) models. Unlike other OPF modeling frameworks, ExaModelsPower.jl leverages the capabilities of ExaModels.jl in order to solve more complex, large-scale versions of the OPF.  ExaModels.jl employs what we call SIMD abstraction for nonlinear programs (NLPs), which allows for the preservation of the parallelizable structure within the model equations, facilitating efficient automatic differentiation either on the single-thread CPUs, multi-threaded CPUs, as well as GPU accelerators. More details about SIMD abstraction can be found here. ExaModels.jl compiles (via Julia's compiler) derivative evaluation codes tailored to each computation pattern. Through reverse-mode automatic differentiation using these tailored codes, ExaModels.jl achieves significantly faster derivative evaluation speeds, even when using CPU.","category":"page"},{"location":"Introduction/","page":"Introduction","title":"Introduction","text":"Recent benchmark results demonstrate that derivative evaluation using ExaModels.jl on GPU can be up to two orders of magnitude faster compared to JuMP or AMPL [1]. This enables us to implement more complex versions of the OPF without needing any relaxations. Currently, ExaModelsPower.jl supports developing models for static OPF, multi-period OPF with or without storage, and security constrained OPF. ExaModelsPower.jl also supports a number of flexible options for the user to specify model coordinate system, setup of time-varying demand profiles, and handling of complementarity constraints for storage models. ","category":"page"},{"location":"Introduction/#Supported-Solvers","page":"Introduction","title":"Supported Solvers","text":"","category":"section"},{"location":"Introduction/","page":"Introduction","title":"Introduction","text":"ExaModelsPower can be used with any solver that can handle NLPModel data type, but several callbacks are not currently implemented, and cause some errors. Currently, it is tested with the following solvers:","category":"page"},{"location":"Introduction/","page":"Introduction","title":"Introduction","text":"Ipopt (via NLPModelsIpopt.jl)\nMadNLP.jl","category":"page"},{"location":"Introduction/#Documentation-Structure","page":"Introduction","title":"Documentation Structure","text":"","category":"section"},{"location":"Introduction/","page":"Introduction","title":"Introduction","text":"This documentation is structured in the following way.","category":"page"},{"location":"Introduction/","page":"Introduction","title":"Introduction","text":"This page provides some introductory information about ExaModelsPower.jl\nThe step-by-step tutorials of using ExaModelsPower.jl can be found in OPF tutorial and MPOPF tutorial.\nThe API Manual provides information on functions provided within ExaModelsPower.jl, as well as information on the constraints and variables implemented in the static and multi-period OPFs","category":"page"},{"location":"Introduction/#Supporting-ExaModelsPower.jl","page":"Introduction","title":"Supporting ExaModelsPower.jl","text":"","category":"section"},{"location":"Introduction/","page":"Introduction","title":"Introduction","text":"Please report issues and feature requests via the GitHub issue tracker.\nQuestions are welcome at GitHub discussion forum.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Welcome to the documentation of ExaModelsPower.jl\t","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Note\nExaModelsPower runs on julia VERSION ≥ v\"1.9\"","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"warning: Warning\nPlease help us improve ExaModelsPower and this documentation! ExaModelsPower is in the early stage of development, and you may encounter unintended behaviors or missing documentations. If you find anything is not working as intended or documentation is missing, please open issues or pull requests or start discussions. ","category":"page"},{"location":"#What-is-ExaModelsPower.jl?","page":"Introduction","title":"What is ExaModelsPower.jl?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"ExaModelsPower.jl is a Julia package for creating optimal power flow (OPF) models. Unlike other OPF modeling frameworks, ExaModelsPower.jl leverages the capabilities of ExaModels.jl in order to solve more complex, large-scale versions of the OPF.  ExaModels.jl employs what we call SIMD abstraction for nonlinear programs (NLPs), which allows for the preservation of the parallelizable structure within the model equations, facilitating efficient automatic differentiation either on the single-thread CPUs, multi-threaded CPUs, as well as GPU accelerators. More details about SIMD abstraction can be found here. ExaModels.jl compiles (via Julia's compiler) derivative evaluation codes tailored to each computation pattern. Through reverse-mode automatic differentiation using these tailored codes, ExaModels.jl achieves significantly faster derivative evaluation speeds, even when using CPU.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Recent benchmark results demonstrate that derivative evaluation using ExaModels.jl on GPU can be up to two orders of magnitude faster compared to JuMP or AMPL [1]. This enables us to implement more complex versions of the OPF without needing any relaxations. Currently, ExaModelsPower.jl supports developing models for static OPF, multi-period OPF with or without storage, and security constrained OPF. ExaModelsPower.jl also supports a number of flexible options for the user to specify model coordinate system, setup of time-varying demand profiles, and handling of complementarity constraints for storage models. ","category":"page"},{"location":"#Supported-Solvers","page":"Introduction","title":"Supported Solvers","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"ExaModelsPower can be used with any solver that can handle NLPModel data type, but several callbacks are not currently implemented, and cause some errors. Currently, it is tested with the following solvers:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Ipopt (via NLPModelsIpopt.jl)\nMadNLP.jl","category":"page"},{"location":"#Documentation-Structure","page":"Introduction","title":"Documentation Structure","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This documentation is structured in the following way.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This page provides some introductory information about ExaModelsPower.jl\nThe step-by-step tutorials of using ExaModelsPower.jl can be found in OPF tutorial and MPOPF tutorial.\nThe API Manual provides information on functions provided within ExaModelsPower.jl, as well as information on the constraints and variables implemented in the static and multi-period OPFs","category":"page"},{"location":"#Supporting-ExaModelsPower.jl","page":"Introduction","title":"Supporting ExaModelsPower.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Please report issues and feature requests via the GitHub issue tracker.\nQuestions are welcome at GitHub discussion forum.","category":"page"},{"location":"ref/#References","page":"References","title":"References","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"S. Shin, V. Rao, M. Schanen, D. A. Maldonado and M. Anitescu. Scalable Multi-Period AC Optimal Power Flow Utilizing GPUs with High Memory Capacities (2024), arXiv:2405.14032 [math.OC].\n\n\n\nF. Geth, C. Coffrin and D. M. Fobes. A Flexible Storage Model for Power Network Optimization (2020), arXiv:2004.14768 [eess.SY].\n\n\n\n","category":"page"}]
}
